import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:fishmatic/data_models.dart';
import 'package:fishmatic/fishmatic.dart';
import 'package:rxdart/rxdart.dart';
import 'package:syncfusion_flutter_gauges/gauges.dart';

// TODO: Exception handling (network errors, null data errors)

Future<Fishmatic> initFishmatic() async {
  final FirebaseAuth _fbAuth = FirebaseAuth.instance;
  final User user = (await _fbAuth.signInAnonymously()).user!;
  final Fishmatic _fm = Fishmatic(user.uid);
  await _fm.initialise();
  return _fm;
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(FishmaticApp());
}

class FishmaticApp extends StatelessWidget {
  final Future<FirebaseApp> _fbApp = Firebase.initializeApp();
  late final Fishmatic _fm;
  @override
  Widget build(BuildContext context) {
    return Container(
      child: FutureBuilder(
        future: _fbApp,
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            print('Firebase init error: ${snapshot.error.toString()}');
            return AlertDialog(
              title: const Text('Fatal Firebase Error'),
              content: Text(
                  'A fatal error was encountered while initialising Firebase:\n' +
                      snapshot.error.toString()),
              actions: <Widget>[
                TextButton(
                    onPressed: () => SystemNavigator.pop(),
                    child: const Text('Exit')),
              ],
            );
          } else if (snapshot.hasData) {
            return FutureBuilder(
                future: initFishmatic(),
                builder:
                    (BuildContext context, AsyncSnapshot<Fishmatic> snapshot) {
                  if (snapshot.hasError) {
                    print(snapshot.error.toString());
                    return AlertDialog(
                      title: const Text('Initialisaton Error'),
                      content: Text(snapshot.error.toString()),
                      actions: <Widget>[
                        TextButton(
                          onPressed: () => SystemNavigator.pop(),
                          child: const Text('Exit'),
                        ),
                      ],
                    );
                  } else if (snapshot.hasData) {
                    _fm = snapshot.data!;
                    print('Signed in Anonymously as user ${_fm.userID}');
                    return HomePage(title: 'Fishmatic', fm: _fm);
                  } else {
                    return Center(
                      child: CircularProgressIndicator(),
                    );
                  }
                });
          } else {
            return Center(
              child: CircularProgressIndicator(),
            );
          }
        },
      ),
    );
  }
}

class _FishmaticApp extends StatelessWidget {
  final Fishmatic _fm;

  _FishmaticApp(this._fm);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Fishmatic',
      theme: ThemeData.dark(),
      home: HomePage(
        title: 'Fishmatic',
        fm: _fm,
      ),
      routes: <String, WidgetBuilder>{
        SchedulesPage.routeName: (BuildContext context) =>
            const SchedulesPage(),
      },
      debugShowCheckedModeBanner: false,
    );
  }
}

class HomePage extends StatefulWidget {
  const HomePage({Key? key, required this.title, required this.fm})
      : super(key: key);

  final String title;
  final Fishmatic fm;

  @override
  _HomePageState createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  final double _gaugeHeight = 200;
  late final StatusMonitor _statusMonitor;
  late final ScheduleManager _scheduleManager;
  List<ListTile> _tempNotifs = [], _turbNotifs = [], _foodNotifs = [];
  double waterTemp = 0.0;
  double waterTurb = 0.0;
  double foodLevel = 0.0;
  // TODO: Check if these variables are even needed
  ValueStatus waterTempStatus = ValueStatus.normal;
  ValueStatus waterTurbStatus = ValueStatus.normal;
  ValueStatus foodLevelStatus = ValueStatus.normalFood;

  _HomePageState() {
    _statusMonitor = widget.fm.statusMonitor;
    print(_statusMonitor.runtimeType);
    _scheduleManager = widget.fm.scheduleManager;
    print(_scheduleManager.runtimeType);
  }

  void _addNotif(List<ListTile> _notifs, String title, String parameter) {
    String _statusText = () {
      switch (parameter) {
        case 'Water temperature':
          return '${_getStatusText(waterTempStatus).toLowerCase()} ($waterTemp \u2103).';
        case 'Water turbidity':
          return '${_getStatusText(waterTurbStatus).toLowerCase()} ($waterTurb NTU).';
        case 'Food level':
          return '${_getStatusText(foodLevelStatus).toLowerCase()}. ' +
              (foodLevelStatus == ValueStatus.lowFood
                  ? 'Refill feeder.'
                  : 'Feeding suspended.');
        default:
          return '';
      }
    }();
    _notifs.add(_getNotifTile(title, '$parameter is $_statusText'));
  }

  void _updateTempNotifs() {
    _tempNotifs.clear();
    switch (waterTempStatus) {
      case ValueStatus.warningLow:
      case ValueStatus.warningHigh:
        _addNotif(_tempNotifs, 'Warning', 'Water temperature');
        break;
      case ValueStatus.criticalLow:
      case ValueStatus.criticalHigh:
        _addNotif(_tempNotifs, 'Critical', 'Water temperature');
        break;
      default:
        break;
    }
  }

  void _updateTurbNotifs() {
    _turbNotifs.clear();
    switch (waterTurbStatus) {
      case ValueStatus.warningHigh:
        _addNotif(_turbNotifs, 'Warning', 'Water turbidity');
        break;
      case ValueStatus.criticalHigh:
        _addNotif(_turbNotifs, 'Critical', 'Water turbidity');
        break;
      default:
        break;
    }
  }

  void _updateFoodNotifs() {
    _foodNotifs.clear();
    switch (foodLevelStatus) {
      case ValueStatus.lowFood:
        _addNotif(_foodNotifs, 'Warning', 'Food level');
        break;
      case ValueStatus.criticalFood:
        _addNotif(_foodNotifs, 'Critical', 'Food level');
        break;
      default:
        break;
    }
  }

  ListTile _getNotifTile(String title, String message) {
    final IconData _iconData = title == 'Warning' ? Icons.error : Icons.warning;
    final Color _iconColor = title == 'Warning' ? Colors.orange : Colors.red;
    return ListTile(
      leading: Icon(
        _iconData,
        color: _iconColor,
        size: 40.0,
      ),
      title: Text(
        title,
        style: TextStyle(color: _iconColor, fontSize: 14),
      ),
      subtitle: Text(
        message,
        style: TextStyle(fontSize: 14),
      ),
      dense: true,
    );
  }

  String _getStatusText(ValueStatus status) {
    switch (status) {
      case ValueStatus.normal:
        return 'Normal';
      case ValueStatus.warningHigh:
        return 'High';
      case ValueStatus.warningLow:
      case ValueStatus.lowFood:
        return 'Low';
      case ValueStatus.criticalHigh:
        return 'Too High';
      case ValueStatus.criticalLow:
        return 'Too Low';
      case ValueStatus.normalFood:
        return 'Adequate';
      case ValueStatus.criticalFood:
        return 'Empty';
    }
  }

  Color _getStatusColor(ValueStatus status) {
    switch (status) {
      case ValueStatus.normal:
      case ValueStatus.normalFood:
        return Colors.green;
      case ValueStatus.warningHigh:
      case ValueStatus.warningLow:
      case ValueStatus.lowFood:
        return Colors.orange;
      case ValueStatus.criticalHigh:
      case ValueStatus.criticalLow:
      case ValueStatus.criticalFood:
        return Colors.red;
    }
  }

  SfRadialGauge radialGauge(
      {required String title,
      required double value,
      required ValueStatus valueStatus,
      required double gaugeMin,
      required double gaugeMax,
      double? minWarning,
      double? maxWarning,
      double? minCritical,
      double? maxCritical,
      required String unit}) {
    // TODO: Compensate for values that overflow gauge limits
    final Color textColor = _getStatusColor(valueStatus);
    minWarning = minWarning ?? gaugeMin;
    minCritical = minCritical ?? minWarning;
    maxWarning = maxWarning ?? gaugeMax;
    maxCritical = maxCritical ?? maxWarning;
    return SfRadialGauge(
      // backgroundColor: Colors.grey,
      title: GaugeTitle(
        text: title,
        textStyle: TextStyle(
          fontSize: 20,
        ),
      ),
      enableLoadingAnimation: true,
      axes: <RadialAxis>[
        RadialAxis(
          minimum: gaugeMin,
          maximum: gaugeMax,
          ranges: <GaugeRange>[
            GaugeRange(
              startValue: gaugeMin,
              endValue: minCritical,
              color: Colors.red,
            ),
            GaugeRange(
              startValue: minCritical,
              endValue: minWarning,
              color: Colors.orange,
            ),
            GaugeRange(
              startValue: minWarning,
              endValue: maxWarning,
              color: Colors.green,
            ),
            GaugeRange(
              startValue: maxWarning,
              endValue: maxCritical,
              color: Colors.orange,
            ),
            GaugeRange(
              startValue: maxCritical,
              endValue: gaugeMax,
              color: Colors.red,
            )
          ],
          pointers: <GaugePointer>[
            MarkerPointer(
              value: value,
              color: Colors.white,
              markerOffset: 5.5,
              markerType: MarkerType.triangle,
              markerHeight: 18,
              enableAnimation: true,
            ),
          ],
          annotations: <GaugeAnnotation>[
            GaugeAnnotation(
              widget: Container(
                child: Text(
                  value.toStringAsFixed(1),
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: textColor,
                  ),
                ),
              ),
              angle: 90,
              positionFactor: 0,
            ),
            GaugeAnnotation(
              widget: Container(
                child: Text(
                  unit,
                  style: TextStyle(
                    fontSize: 16,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
              angle: 90,
              positionFactor: 0.25,
            ),
          ],
        )
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          widget.title,
          style: TextStyle(
            fontSize: 25.0,
            fontStyle: FontStyle.italic,
          ),
        ),
        centerTitle: true,
      ),
      body: SafeArea(
        child: LayoutBuilder(
          builder: (BuildContext context, BoxConstraints viewportConstraints) =>
              SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                StreamBuilder(
                  stream: CombineLatestStream.list([
                    _statusMonitor.getValueStream(Fishmatic.waterTemp,
                        maxWarning: 30,
                        maxCritical: 35,
                        minWarning: 20,
                        minCritical: 15),
                    _statusMonitor.getValueStream(
                      Fishmatic.waterTurb,
                      maxWarning: 7.5,
                      maxCritical: 10,
                    ),
                    _statusMonitor.getValueStream(
                      Fishmatic.foodLevel,
                      minWarning: 5,
                      minCritical: 1,
                      isFoodLevel: true,
                    ),
                  ]),
                  builder: (BuildContext context,
                      AsyncSnapshot<List<StreamData>> snapshot) {
                    // TODO: Check more accurately using connection state
                    if (snapshot.hasData) {
                      final StreamData _tempData = snapshot.data![0];
                      final StreamData _turbData = snapshot.data![1];
                      final StreamData _foodData = snapshot.data![2];
                      if (_tempData.value != null && _tempData.status != null) {
                        waterTemp = _tempData.value!;
                        waterTempStatus = _tempData.status!;
                        _updateTempNotifs();
                        print(
                            'water temperature updated: ${_tempData.toString()}');
                      }
                      if (_turbData.value != null && _turbData.status != null) {
                        waterTurb = _turbData.value!;
                        waterTurbStatus = _turbData.status!;
                        _updateTurbNotifs();
                        print(
                            'water turbidity updated: ${_turbData.toString()}');
                      }
                      if (_foodData.value != null && _foodData.status != null) {
                        foodLevel = _foodData.value!;
                        foodLevelStatus = _foodData.status!;
                        _updateFoodNotifs();
                        print('food level updated: ${_foodData.toString()}');
                      }
                    } else if (snapshot.hasError) {
                      print('Error: ${snapshot.error.toString()}');
                    }
                    return ListView(
                      shrinkWrap: true,
                      physics: const NeverScrollableScrollPhysics(),
                      children: <Widget>[
                        Row(
                          children: <Widget>[
                            Flexible(
                              flex: 1,
                              fit: FlexFit.loose,
                              child: Padding(
                                padding:
                                    EdgeInsets.fromLTRB(8.0, 8.0, 8.0, 0.0),
                                child: SizedBox(
                                  height: _gaugeHeight,
                                  child: radialGauge(
                                      title: 'Temperature',
                                      value: waterTemp,
                                      valueStatus: waterTempStatus,
                                      gaugeMin: 10,
                                      gaugeMax: 40,
                                      minWarning: 20,
                                      minCritical: 15,
                                      maxWarning: 30,
                                      maxCritical: 35,
                                      unit: '\u2103'),
                                ),
                              ),
                            ),
                            Flexible(
                              flex: 1,
                              fit: FlexFit.loose,
                              child: Padding(
                                padding:
                                    EdgeInsets.fromLTRB(8.0, 8.0, 8.0, 0.0),
                                child: SizedBox(
                                  height: _gaugeHeight,
                                  child: radialGauge(
                                    title: 'Turbidity',
                                    value: waterTurb,
                                    valueStatus: waterTurbStatus,
                                    gaugeMin: 0,
                                    gaugeMax: 15,
                                    maxWarning: 7.5,
                                    maxCritical: 10,
                                    unit: 'NTU',
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ),
                        Center(
                          child: Padding(
                            padding: EdgeInsets.fromLTRB(8.0, 0.0, 8.0, 6.0),
                            child: Text(
                              'Food Level',
                              style: TextStyle(
                                fontSize: 20.0,
                              ),
                            ),
                          ),
                        ),
                        Column(
                          children: <Widget>[
                            Padding(
                              padding: EdgeInsets.fromLTRB(
                                  8.0,
                                  0.0,
                                  8.0,
                                  foodLevelStatus == ValueStatus.normalFood
                                      ? 16.0
                                      : 6.0),
                              child: Text(
                                _getStatusText(foodLevelStatus).toUpperCase(),
                                style: TextStyle(
                                  color: _getStatusColor(foodLevelStatus),
                                  fontSize: 20.0,
                                  fontWeight: FontWeight.bold,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ],
                        ),
                        ...(_tempNotifs + _turbNotifs + _foodNotifs)
                      ],
                    );
                  },
                ),
                FutureBuilder(
                  future: _scheduleManager.activeSchedule,
                  builder: (BuildContext context,
                      AsyncSnapshot<Schedule?> snapshot) {
                    late Widget _child;
                    switch (snapshot.connectionState) {
                      case ConnectionState.active:
                      case ConnectionState.waiting:
                        _child = CircularProgressIndicator();
                        break;
                      case ConnectionState.none:
                        _child = Text(
                          'No Active Schedule',
                          style: TextStyle(
                            fontSize: 20,
                          ),
                        );
                        break;
                      case ConnectionState.done:
                        if (snapshot.data != null) {
                          final Schedule _active = snapshot.data!;
                          _child = _infoList(_active.name, {
                            Icon(Icons.av_timer):
                                _active.interval.toString() + ' Hours',
                            Icon(Icons.timelapse):
                                '${_active.sTime.hour.toString().padLeft(2, '0')}:${_active.sTime.minute.toString().padLeft(2, '0')} to ${_active.eTime.hour.toString().padLeft(2, '0')}:${_active.eTime.minute.toString().padLeft(2, '0')}',
                            Icon(Icons.fastfood):
                                _active.amount.toStringAsFixed(1),
                          }, () {
                            setState(() {});
                          });
                        } else
                          _child = CircularProgressIndicator();
                        break;
                    }
                    return Padding(
                      padding: const EdgeInsets.fromLTRB(4.0, 16.0, 4.0, 0.0),
                      child: Card(
                        child: Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: <Widget>[
                              Padding(
                                padding: const EdgeInsets.only(top: 16),
                                child: Text(
                                  'Current Active Schedule',
                                  style: TextStyle(
                                      fontSize: 20,
                                      fontWeight: FontWeight.bold),
                                ),
                              ),
                              _child,
                            ],
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {},
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ),
    );
  }
}

class SchedulesPage extends StatefulWidget {
  const SchedulesPage({Key? key}) : super(key: key);

  static const String routeName = '/schedules';

  @override
  _SchedulesPageState createState() => _SchedulesPageState();
}

class _SchedulesPageState extends State<SchedulesPage> {
  late final ScheduleManager _sManager;

  _SchedulesPageState() {
    _sManager = ModalRoute.of(context)!.settings.arguments as ScheduleManager;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Schedules',
          style: TextStyle(
            fontSize: 25.0,
            fontStyle: FontStyle.italic,
          ),
        ),
      ),
      body: SafeArea(
        child: LayoutBuilder(
          builder: (BuildContext context, BoxConstraints viewportConstraints) =>
              SingleChildScrollView(),
        ),
      ),
    );
  }
}

Column _infoList(String name, Map<Icon, String> infoMap, Function onChange) {
  List<Widget> _info = [
    ListTile(
        title: Text(
      name,
      style: TextStyle(fontSize: 16),
    ))
  ];
  infoMap.entries.forEach((entry) {
    _info.add(ListTile(
      leading: entry.key,
      title: Text(
        entry.value,
        style: TextStyle(fontSize: 16),
      ),
      dense: true,
      visualDensity: VisualDensity(
          horizontal: VisualDensity.maximumDensity,
          vertical: VisualDensity.minimumDensity),
    ));
  });
  _info.add(Row(
    mainAxisAlignment: MainAxisAlignment.end,
    children: <Widget>[
      Padding(
        padding: const EdgeInsets.only(right: 8.0),
        child: ElevatedButton(
          onPressed: () {
            onChange();
          },
          child: Padding(
            padding: const EdgeInsets.all(8.0),
            child: Text('Change'),
          ),
          // style: ElevatedButton.styleFrom(
          //     onSurface: Colors.teal, onPrimary: Colors.teal),
        ),
      )
    ],
  ));
  return Column(
    mainAxisSize: MainAxisSize.min,
    children: _info,
  );
}
